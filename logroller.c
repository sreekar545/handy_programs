#include <time.h>
#include <stdio.h>
#include <limits.h>
#include <signal.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <stdlib.h>
#include <string.h>

FILE *f1;
char *log_file_name;
long time_interval=60*60*24; //default 1 day = 60*60*24 seconds
long max_size = 10*1000*1000; // 1000*1000 bytes = 1MB

void callback_alarm_handler(int sig_no)
{
	struct stat stat_buf;
        stat(log_file_name, &stat_buf);
        if(stat_buf.st_size >= max_size)
	{
		// Rename current.log to current.1.log
		fflush(f1);
		fclose(f1);
		int file_count = 1;
		while(1)
		{
		  
		  char *new_log_file = (char*) malloc(strlen(log_file_name)+10);
		  char *file_count_str = (char*) malloc(3);
		  sprintf(file_count_str,"%d",file_count);
		  strncpy(new_log_file,log_file_name,strlen(log_file_name)-4);
		  strcat(new_log_file,file_count_str);
		  strcat(new_log_file,".log");   
		//try to see if it exists 
		   if( access(new_log_file, F_OK ) == -1 ) 
		   {
  		   	// It doesn't exist, GO ahead and rename
			rename(log_file_name,new_log_file);
			f1 = fopen(log_file_name,"w");
		        break;	
		   } 
		   file_count++;
		}
		// Assign file desciptor to the new current.log
		
	}
        fflush(f1);
        alarm(time_interval);
}

void callback_terminate_handler(int sig_no)
{
	printf("Flushing log file stream and exiting...");
	fflush(f1);
	fclose(f1);
	exit(0);
}

void callback_exit_handler(void)
{
        printf("Flushing log file stream and exiting...");
        fflush(f1);
        fclose(f1);
        exit(0);
}



int main(int argc, char *argv[] ) {
	/*
		Command line arguments:
		INTERVAL => time to wait before checking the log file size
		LOG_FILiE_NAME => file name to be written to (Overwrites if exists)
		MAX_SIZE => Max log file size where we need to truncate it
	*/
	if(argc<3)
	{
		printf("\n---logroller takes three arguments---\n");
		printf("\nlog file name: The name of the log file that will be created");
		printf("\nInterval: The duration at which log size needs to be checked");
		printf("\nmax size: The maximum file size where log will be truncated\n\n ");		     exit(-1);
	}

        log_file_name = argv[1];
	char *ptr;
	time_interval = strtol(argv[2],&ptr,10);
	max_size = strtol(argv[3],&ptr,10);

	char c;
        int count=(INT_MAX/10);
	
	// This is for handling flush and close stream before exit	
	atexit(callback_exit_handler);
	
        alarm(3);
        // This alarm signal is generated by us
	// We check for the file size periodically rather than
	// checking the counter or file_size before writing each line or char
	// I find it efficient, if you have other ideas you can use them
	signal(SIGALRM,callback_alarm_handler);
	
	// As SIGTERM/SIGSEGV/SIGKILL etc are going to kill the process
	// it's necessary to flush everything and close file handles
	// TODO:Need to add other signals which can kill process
	signal(SIGTERM, callback_terminate_handler);
	signal(SIGKILL, callback_terminate_handler);

        printf("Opening file for writng...");

	f1 = fopen(log_file_name,"w");

	while(((c=getchar())) != EOF)
	{
		putc(c,f1);
	}

	return 0;
}
